using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using BepInEx.Logging;

namespace GreyHackRussianPlugin.DebugTools
{
    /// <summary>
    /// Класс для отладки и анализа переводов эксплойтов
    /// </summary>
    public class DebugTranslationExploit
    {
        // Словарь для кэширования переведенных описаний
        private Dictionary<string, string> translationCache = new Dictionary<string, string>();

        // Счетчики
        private int translatedCount = 0;
        private int untranslatedCount = 0;

        // Путь к XML файлу с непереведенными текстами
        private readonly string untranslatedXmlPath;

        // Порог перевода - если переведено менее X% слов, считаем текст непереведенным
        private readonly float translationThreshold = 0.7f; // 70%

        // Список игнорируемых слов (имена, числа и т.д.)
        private readonly HashSet<string> ignoredWords = new HashSet<string>();

        // Логгер
        private readonly ManualLogSource _logger;

        /// <summary>
        /// Создает новый экземпляр отладчика переводов эксплойтов
        /// </summary>
        /// <param name="logger">Логгер для вывода сообщений</param>
        /// <param name="pluginPath">Путь к директории плагина</param>
        /// <param name="ignoredWords">Список игнорируемых слов</param>
        public DebugTranslationExploit(ManualLogSource logger, string pluginPath, HashSet<string> ignoredWords = null)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            untranslatedXmlPath = Path.Combine(
                pluginPath,
                "ExploitPatch",
                "untranslated_texts.xml"
            );

            // Инициализация списка игнорируемых слов
            if (ignoredWords != null)
            {
                this.ignoredWords = ignoredWords;
            }
            else
            {
                // Стандартный список игнорируемых слов
                this.ignoredWords = new HashSet<string>
                {
                    "libssh", "libftp", "libhttp", "libsmtp", "libchat", "libadb",
                    "v1.0.0", "v1.0.1", "v1.1.0", "v1.2.0", "v2.0.0",
                    "ssh", "ftp", "http", "smtp", "chat", "adb", "rshell", "cam",
                    "root", "guest", "/bin", "/usr", "/sys", "/etc", "/lib", "/home",
                    "Mail.txt", "passwd", ">="
                };
            }

            // Инициализация XML
            EnsureDirectoriesExist();
            InitializeXmlFile();
        }

        /// <summary>
        /// Проверка и создание необходимых директорий
        /// </summary>
        private void EnsureDirectoriesExist()
        {
            try
            {
                string exploitPatchDir = Path.GetDirectoryName(untranslatedXmlPath);
                if (!Directory.Exists(exploitPatchDir))
                {
                    Directory.CreateDirectory(exploitPatchDir);
                    _logger.LogInfo($"Создана директория для отладки переводов: {exploitPatchDir}");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"Ошибка при создании директорий: {ex.Message}");
            }
        }

        /// <summary>
        /// Инициализация XML-файла для непереведенных текстов
        /// </summary>
        private void InitializeXmlFile()
        {
            try
            {
                if (!File.Exists(untranslatedXmlPath))
                {
                    XmlDocument xmlDoc = new XmlDocument();

                    // Добавляем комментарий с описанием файла - исправлено форматирование
                    XmlComment comment = xmlDoc.CreateComment(@"
    Файл содержит непереведенные или частично переведенные тексты эксплойтов.
    
    Структура файла:
    <untranslated_texts> - корневой элемент
        <statistics> - статистическая информация
            <total_texts> - общее количество обработанных текстов
            <fully_translated> - полностью переведенные тексты
            <partially_translated> - частично переведенные тексты
            <untranslated> - непереведенные тексты
            <coverage_percentage> - процент покрытия переводами
        </statistics>
        
        <items> - список непереведенных текстов
            <item id=""1"" timestamp=""2023-10-15T14:30:25"" quality=""0.2""> - элемент с непереведенным текстом
                <original> - оригинальный текст
                    Текст оригинала
                </original>
                <partial_translation> - частичный перевод (если есть)
                    Текст частичного перевода
                </partial_translation>
                <untranslated_terms> - непереведенные термины (если анализ доступен)
                    <term>термин 1</term>
                    <term>термин 2</term>
                </untranslated_terms>
            </item>
        </items>
    </untranslated_texts>
    ");


                    XmlDeclaration xmlDeclaration = xmlDoc.CreateXmlDeclaration("1.0", "UTF-8", null);
                    xmlDoc.AppendChild(xmlDeclaration);

                    xmlDoc.AppendChild(comment);

                    XmlElement rootElement = xmlDoc.CreateElement("untranslated_texts");
                    xmlDoc.AppendChild(rootElement);

                    XmlElement statisticsElement = xmlDoc.CreateElement("statistics");
                    rootElement.AppendChild(statisticsElement);

                    AddStatElement(xmlDoc, statisticsElement, "total_texts", "0");
                    AddStatElement(xmlDoc, statisticsElement, "fully_translated", "0");
                    AddStatElement(xmlDoc, statisticsElement, "partially_translated", "0");
                    AddStatElement(xmlDoc, statisticsElement, "untranslated", "0");
                    AddStatElement(xmlDoc, statisticsElement, "coverage_percentage", "0%");

                    XmlElement itemsElement = xmlDoc.CreateElement("items");
                    rootElement.AppendChild(itemsElement);

                    xmlDoc.Save(untranslatedXmlPath);
                    _logger.LogInfo($"Создан XML-файл для непереведенных текстов: {untranslatedXmlPath}");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"Ошибка при инициализации XML-файла: {ex.Message}");
            }
        }

        /// <summary>
        /// Вспомогательный метод для добавления элемента статистики
        /// </summary>
        private void AddStatElement(XmlDocument xmlDoc, XmlElement parent, string name, string value)
        {
            XmlElement element = xmlDoc.CreateElement(name);
            element.InnerText = value;
            parent.AppendChild(element);
        }

        /// <summary>
        /// Сохраняет непереведенный текст в XML файл
        /// </summary>
        public void SaveUntranslatedTextToXml(string original, string partialTranslation, float quality)
        {
            try
            {
                // Проверяем существование директории
                string directory = Path.GetDirectoryName(untranslatedXmlPath);
                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                // Создаем файл, если не существует
                if (!File.Exists(untranslatedXmlPath))
                {
                    InitializeXmlFile();
                }

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(untranslatedXmlPath);

                // Получаем корневой элемент
                XmlElement rootElement = xmlDoc.DocumentElement;

                // Получаем элемент items
                XmlElement itemsElement = (XmlElement)rootElement.SelectSingleNode("items");
                if (itemsElement == null)
                {
                    itemsElement = xmlDoc.CreateElement("items");
                    rootElement.AppendChild(itemsElement);
                }

                // Проверяем, существует ли уже этот текст
                XmlNodeList existingItems = itemsElement.SelectNodes($"item/original[text()='{EscapeXml(original)}']");
                if (existingItems.Count > 0)
                {
                    // Текст уже существует, обновляем его
                    foreach (XmlNode existingItem in existingItems)
                    {
                        XmlElement itemElement = (XmlElement)existingItem.ParentNode;
                        itemElement.SetAttribute("timestamp", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss"));
                        itemElement.SetAttribute("quality", quality.ToString("0.00"));

                        XmlElement translationElement = (XmlElement)itemElement.SelectSingleNode("partial_translation");
                        if (translationElement == null)
                        {
                            translationElement = xmlDoc.CreateElement("partial_translation");
                            itemElement.AppendChild(translationElement);
                        }
                        translationElement.InnerText = partialTranslation;

                        // Получаем непереведенные термины
                        List<string> untranslatedTerms = GetUntranslatedTerms(original, partialTranslation);

                        // Обновляем список непереведенных терминов
                        XmlElement termsElement = (XmlElement)itemElement.SelectSingleNode("untranslated_terms");
                        if (termsElement == null)
                        {
                            termsElement = xmlDoc.CreateElement("untranslated_terms");
                            itemElement.AppendChild(termsElement);
                        }
                        else
                        {
                            termsElement.InnerXml = ""; // Очищаем существующие термины
                        }

                        // Добавляем новые термины
                        foreach (string term in untranslatedTerms)
                        {
                            XmlElement termElement = xmlDoc.CreateElement("term");
                            termElement.InnerText = term;
                            termsElement.AppendChild(termElement);
                        }
                    }
                }
                else
                {
                    // Создаем новый элемент item
                    XmlElement itemElement = xmlDoc.CreateElement("item");
                    itemElement.SetAttribute("id", (itemsElement.ChildNodes.Count + 1).ToString());
                    itemElement.SetAttribute("timestamp", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss"));
                    itemElement.SetAttribute("quality", quality.ToString("0.00"));

                    // Добавляем оригинальный текст
                    XmlElement originalElement = xmlDoc.CreateElement("original");
                    originalElement.InnerText = original;
                    itemElement.AppendChild(originalElement);

                    // Добавляем частичный перевод
                    XmlElement translationElement = xmlDoc.CreateElement("partial_translation");
                    translationElement.InnerText = partialTranslation;
                    itemElement.AppendChild(translationElement);

                    // Получаем непереведенные термины
                    List<string> untranslatedTerms = GetUntranslatedTerms(original, partialTranslation);

                    // Добавляем список непереведенных терминов
                    if (untranslatedTerms.Count > 0)
                    {
                        XmlElement termsElement = xmlDoc.CreateElement("untranslated_terms");
                        itemElement.AppendChild(termsElement);

                        foreach (string term in untranslatedTerms)
                        {
                            XmlElement termElement = xmlDoc.CreateElement("term");
                            termElement.InnerText = term;
                            termsElement.AppendChild(termElement);
                        }
                    }

                    // Добавляем элемент в список
                    itemsElement.AppendChild(itemElement);
                }

                // Обновляем статистику
                UpdateStatistics(xmlDoc);

                // Сохраняем файл
                xmlDoc.Save(untranslatedXmlPath);

                _logger.LogInfo($"Сохранен непереведенный текст в XML файл (качество перевода: {quality:P0})");
            }
            catch (Exception ex)
            {
                _logger.LogError($"Ошибка при сохранении непереведенного текста в XML: {ex.Message}");
            }
        }

        /// <summary>
        /// Экранирует специальные символы XML
        /// </summary>
        private string EscapeXml(string text)
        {
            return text.Replace("&", "&amp;")
                       .Replace("<", "&lt;")
                       .Replace(">", "&gt;")
                       .Replace("\"", "&quot;")
                       .Replace("'", "&apos;");
        }

        /// <summary>
        /// Обновляет статистику в XML файле
        /// </summary>
        private void UpdateStatistics(XmlDocument xmlDoc)
        {
            try
            {
                XmlElement statisticsElement = (XmlElement)xmlDoc.DocumentElement.SelectSingleNode("statistics");
                if (statisticsElement == null)
                {
                    statisticsElement = xmlDoc.CreateElement("statistics");
                    xmlDoc.DocumentElement.PrependChild(statisticsElement);
                }

                // Подсчитываем статистику
                int totalTexts = translatedCount + untranslatedCount;
                int fullyTranslated = translatedCount;
                int partiallyTranslated = 0;
                int untranslated = 0;

                // Подсчитываем частично переведенные и непереведенные тексты
                XmlNodeList items = xmlDoc.DocumentElement.SelectNodes("items/item");
                foreach (XmlNode item in items)
                {
                    float quality;
                    if (float.TryParse(((XmlElement)item).GetAttribute("quality"), out quality))
                    {
                        if (quality <= 0.1f)
                            untranslated++;
                        else
                            partiallyTranslated++;
                    }
                }

                // Рассчитываем процент покрытия
                float coveragePercentage = totalTexts > 0 ? (float)fullyTranslated / totalTexts : 0;

                // Обновляем элементы статистики
                UpdateStatElement(statisticsElement, "total_texts", totalTexts.ToString());
                UpdateStatElement(statisticsElement, "fully_translated", fullyTranslated.ToString());
                UpdateStatElement(statisticsElement, "partially_translated", partiallyTranslated.ToString());
                UpdateStatElement(statisticsElement, "untranslated", untranslated.ToString());
                UpdateStatElement(statisticsElement, "coverage_percentage", $"{coveragePercentage:P0}");
            }
            catch (Exception ex)
            {
                _logger.LogError($"Ошибка при обновлении статистики: {ex.Message}");
            }
        }

        /// <summary>
        /// Обновляет элемент статистики
        /// </summary>
        private void UpdateStatElement(XmlElement statisticsElement, string name, string value)
        {
            XmlElement element = (XmlElement)statisticsElement.SelectSingleNode(name);
            if (element == null)
            {
                element = statisticsElement.OwnerDocument.CreateElement(name);
                statisticsElement.AppendChild(element);
            }
            element.InnerText = value;
        }

        /// <summary>
        /// Получает список непереведенных терминов путем сравнения оригинального и переведенного текста
        /// </summary>
        public List<string> GetUntranslatedTerms(string original, string translation)
        {
            List<string> untranslatedTerms = new List<string>();

            // Делим на слова
            string[] originalWords = original.Split(new[] { ' ', '\n', '\t', '.', ',', ';', ':', '(', ')', '[', ']', '<', '>' }, StringSplitOptions.RemoveEmptyEntries);

            // Формируем потенциальные термины (слова и словосочетания длиной до 3 слов)
            for (int i = 0; i < originalWords.Length; i++)
            {
                string word = originalWords[i].Trim().ToLower();

                // Пропускаем игнорируемые слова и короткие слова
                if (ignoredWords.Contains(word) || word.Length < 4)
                    continue;

                // Проверяем термин длиной 1 слово
                if (!translation.ToLower().Contains(word) && !untranslatedTerms.Contains(word))
                {
                    untranslatedTerms.Add(originalWords[i]);
                }

                // Проверяем термины длиной 2-3 слова
                for (int j = 1; j <= 2 && i + j < originalWords.Length; j++)
                {
                    string phrase = string.Join(" ", originalWords, i, j + 1);
                    if (!translation.ToLower().Contains(phrase.ToLower()) && !untranslatedTerms.Contains(phrase))
                    {
                        untranslatedTerms.Add(phrase);
                    }
                }
            }

            return untranslatedTerms;
        }

        /// <summary>
        /// Проверяет, является ли текст непереведенным на основе порога перевода
        /// </summary>
        public bool IsUntranslated(string original, string translated)
        {
            if (original == translated) return true;

            // Делим на слова и считаем переведенные
            string[] originalWords = original.Split(new[] { ' ', '\n', '\t', '.', ',', ';', ':', '(', ')', '[', ']', '<', '>' },
                StringSplitOptions.RemoveEmptyEntries);

            string[] translatedWords = translated.Split(new[] { ' ', '\n', '\t', '.', ',', ';', ':', '(', ')', '[', ']', '<', '>' },
                StringSplitOptions.RemoveEmptyEntries);

            // Исключаем игнорируемые слова
            int originalCount = 0;
            foreach (var word in originalWords)
            {
                if (!ignoredWords.Contains(word.Trim().ToLower()))
                    originalCount++;
            }

            if (originalCount == 0) return false; // Все слова игнорируемые

            // Считаем процент переведенных слов (если совпадают оригинал и перевод, слово не переведено)
            float translationPercent = 1.0f - (float)Math.Min(originalCount, translatedWords.Length) / (float)originalCount;

            return translationPercent < translationThreshold;
        }

        /// <summary>
        /// Рассчитывает примерное качество перевода (от 0.0 до 1.0)
        /// </summary>
        public float CalculateTranslationQuality(string original, string translated)
        {
            // Делим на слова
            string[] originalWords = original.Split(new[] { ' ', '\n', '\t', '.', ',', ';', ':', '(', ')', '[', ']', '<', '>' },
                StringSplitOptions.RemoveEmptyEntries);

            string[] translatedWords = translated.Split(new[] { ' ', '\n', '\t', '.', ',', ';', ':', '(', ')', '[', ']', '<', '>' },
                StringSplitOptions.RemoveEmptyEntries);

            // Исключаем игнорируемые слова
            int originalCount = 0;
            int sameWordsCount = 0;

            // Подсчитываем количество значимых слов в оригинале
            foreach (var word in originalWords)
            {
                string trimmedWord = word.Trim().ToLower();
                if (!ignoredWords.Contains(trimmedWord) && trimmedWord.Length >= 3)
                {
                    originalCount++;

                    // Проверяем, есть ли это слово в переводе
                    if (translated.ToLower().Contains(trimmedWord))
                    {
                        sameWordsCount++;
                    }
                }
            }

            if (originalCount == 0) return 1.0f; // Все слова игнорируемые или очень короткие

            // Возвращаем долю переведенных слов
            return 1.0f - ((float)sameWordsCount / (float)originalCount);
        }

        /// <summary>
        /// Проверка и кэширование перевода
        /// </summary>
        public bool TryGetCachedTranslation(string original, out string translation)
        {
            return translationCache.TryGetValue(original, out translation);
        }

        /// <summary>
        /// Добавляет перевод в кэш
        /// </summary>
        public void AddToCache(string original, string translation)
        {
            translationCache[original] = translation;
        }

        /// <summary>
        /// Увеличивает счетчик переведенных текстов
        /// </summary>
        public void IncrementTranslatedCount()
        {
            translatedCount++;
        }

        /// <summary>
        /// Увеличивает счетчик непереведенных текстов
        /// </summary>
        public void IncrementUntranslatedCount()
        {
            untranslatedCount++;
        }

        /// <summary>
        /// Возвращает текущее количество переведенных текстов
        /// </summary>
        public int GetTranslatedCount()
        {
            return translatedCount;
        }

        /// <summary>
        /// Возвращает текущий порог качества перевода
        /// </summary>
        public float GetTranslationThreshold()
        {
            return translationThreshold;
        }
    }
}