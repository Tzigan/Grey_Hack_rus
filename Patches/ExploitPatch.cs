using HarmonyLib;
using System;
using System.IO;
using System.Reflection;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Text;
using UnityEngine;

namespace GreyHackRussianPlugin.Patches
{
    /// <summary>
    /// Патч метода GetShopDescription с интеллектуальным сопоставлением текстов
    /// </summary>
    [HarmonyPatch(typeof(Exploit), "GetShopDescription")]
    public class ExploitPatch
    {
        // Словарь для кэширования переведенных описаний
        private static readonly Dictionary<string, string> translationCache = new Dictionary<string, string>();

        // Счетчик переведенных описаний
        private static int translatedCount = 0;

        // Счетчик непереведенных описаний
        private static int untranslatedCount = 0;

        // Флаг для предотвращения многократной записи одних и тех же текстов в debug-файлы
        private static bool hasDebuggedTranslation = false;

        // Порог перевода - если переведено менее X% слов, считаем текст непереведенным
        private static readonly float translationThreshold = 0.7f; // 70%

        // Список игнорируемых слов (имена, числа и т.д.)
        private static readonly HashSet<string> ignoredWords = new HashSet<string>
        {
            "libssh", "libftp", "libhttp", "libsmtp", "libchat", "libadb",
            "v1.0.0", "v1.0.1", "v1.1.0", "v1.2.0", "v2.0.0",
            "ssh", "ftp", "http", "smtp", "chat", "adb", "rshell", "cam",
            "root", "guest", "/bin", "/usr", "/sys", "/etc", "/lib", "/home",
            "Mail.txt", "passwd", ">="
        };

        // Список общих фраз для замены
        private static readonly Dictionary<string, string> commonPhrases = new Dictionary<string, string>
        {
            { "Get access to a shell.", "Получить доступ к командной оболочке." },
            { "Remote use.", "Удаленное использование." },
            { "For local use only.", "Только для локального использования." },
            { "Permissions obtained:", "Получаемые права:" },
            { "Target:", "Цель:" },
            { "Required:", "Требуется:" },
            { "guest", "guest" },
            { "root", "root" },
            { "Non root user", "Пользователь без root-прав" },
            { "Root user logged in the computer", "Root-пользователь авторизован в системе" },
            { "Guest user logged in the computer", "Guest авторизован в системе" },
            { "Any user logged in the computer", "Любой пользователь авторизован в системе" },
            { "Take advantage of a vulnerability in the", "Использует уязвимость в сервисе" },
            { "service to inject a new password to a registered user", "для внедрения нового пароля зарегистрированному пользователю" },
            { "Search all the Bank credentials files in the computer to decipher all passwords", "Найти и расшифровать все файлы учетных данных Банка в компьютере" },
            { "It is necessary to have the decipher program installed in the computer that launch the exploit", "Необходимо иметь программу расшифровки, установленную на компьютере, с которого запускается эксплойт" },
            { "Prints the contents of the file", "Отображает содержимое файла" },
            { "Grant access to the file", "Предоставляет доступ к файлу" },
            { "Grant access to the path", "Предоставляет доступ к пути" },
            { "and prints their contents", "и выводит его содержимое" },
            { "and decipher its contents", "и расшифровывает его содержимое" },
            { "of all users in the computer", "всех пользователей в компьютере" },
            { "Change all firewall entries to \"allowed\"", "Изменить все записи брандмауэра на \"разрешено\"" },
            { "Unlock the settings of the smart device.", "Разблокировать настройки умного устройства." }
        };

        // Шаблоны для замены
        private static readonly Dictionary<string, string> patterns = new Dictionary<string, string>
        {
            { @"Dependencies on library ([a-z0-9_\.]+) >= ([0-9\.]+)", "Зависимость от библиотеки $1 >= $2" },
            { @"Minimum number of ([0-9]+) users registered in the computer", "Минимум $1 пользователь зарегистрирован в системе" },
            { @"([\\/a-zA-Z0-9_\.]+) exists in the file system", "$1 существует в файловой системе" },
            { @"([0-9]+) port forwarding configured from router to the target computer", "$1 перенаправление порта настроено с маршрутизатора на целевой компьютер" }
        };

        // Специальные случаи для полных путей и фраз
        private static readonly Dictionary<string, string> specialCases = new Dictionary<string, string>
        {
            { "/home/user/Mail.txt of all users in the computer", "/home/user/Mail.txt всех пользователей в компьютере" },
            { "<color=#0FABFFFF>ssh</color>", "<color=#0FABFFFF>ssh</color>" },
            { "<color=#0FABFFFF>ftp</color>", "<color=#0FABFFFF>ftp</color>" },
            { "<color=#0FABFFFF>http</color>", "<color=#0FABFFFF>http</color>" },
            { "<color=#0FABFFFF>smtp</color>", "<color=#0FABFFFF>smtp</color>" },
            { "<color=#0FABFFFF>chat</color>", "<color=#0FABFFFF>chat</color>" },
            { "<color=#0FABFFFF>cam</color>", "<color=#0FABFFFF>cam</color>" },
            { "<color=#0FABFFFF>rshell</color>", "<color=#0FABFFFF>rshell</color>" },
            { "<color=#0FABFFFF>repository</color>", "<color=#0FABFFFF>repository</color>" },
            { "<color=#0FABFFFF>blockchain</color>", "<color=#0FABFFFF>blockchain</color>" },
            { "<color=#0FABFFFF>adb</color>", "<color=#0FABFFFF>adb</color>" },
            { "<color=#0FABFFFF>smartappliance</color>", "<color=#0FABFFFF>smartappliance</color>" },
            { "<color=#0FABFFFF>aptclient</color>", "<color=#0FABFFFF>aptclient</color>" },
            { "<color=#0FABFFFF>net</color>", "<color=#0FABFFFF>net</color>" }
        };

        // Инициализация - должна вызываться при старте плагина
        public static void Initialize()
        {
            GreyHackRussianPlugin.Log.LogInfo("Инициализация ExploitPatch...");

            // Обеспечить существование директорий
            EnsureDirectoriesExist();
        }

        /// <summary>
        /// Проверка и создание необходимых директорий
        /// </summary>
        private static void EnsureDirectoriesExist()
        {
            try
            {
                string translationsPath = Path.Combine(GreyHackRussianPlugin.PluginPath, "Translation");
                if (!Directory.Exists(translationsPath))
                {
                    Directory.CreateDirectory(translationsPath);
                    GreyHackRussianPlugin.Log.LogInfo($"Создана директория для переводов: {translationsPath}");
                }
            }
            catch (Exception ex)
            {
                GreyHackRussianPlugin.Log.LogError($"Ошибка при создании директорий: {ex.Message}");
            }
        }

        /// <summary>
        /// Сохраняет непереведенный текст в файл debug_untranslated.txt
        /// </summary>
        /// <param name="original">Оригинальный текст для сохранения</param>
        public static void SaveUntranslatedText(string original)
        {
            if (string.IsNullOrWhiteSpace(original)) return;

            try
            {
                string untranslatedPath = Path.Combine(GreyHackRussianPlugin.PluginPath, "debug_untranslated.txt");
                using (StreamWriter writer = new StreamWriter(untranslatedPath, true, Encoding.UTF8))
                {
                    writer.WriteLine(original);
                    writer.WriteLine();
                    writer.WriteLine("---");
                    writer.WriteLine();
                }

                untranslatedCount++;
                GreyHackRussianPlugin.Log.LogInfo($"Сохранен непереведенный текст #{untranslatedCount}");
            }
            catch (Exception ex)
            {
                GreyHackRussianPlugin.Log.LogError($"Ошибка при сохранении непереведенного текста: {ex.Message}");
                GreyHackRussianPlugin.Log.LogDebug($"Stack trace: {ex.StackTrace}");
            }
        }

        /// <summary>
        /// Обрабатывает файл debug_untranslated.txt, создавая переводы строк и добавляя их в файл переводов
        /// </summary>
        public static void ProcessUntranslatedTexts()
        {
            string untranslatedPath = Path.Combine(GreyHackRussianPlugin.PluginPath, "debug_untranslated.txt");
            string translationsPath = Path.Combine(GreyHackRussianPlugin.PluginPath, "Translation\\russian_translation.txt");

            // Проверяем существование директорий
            string translationDirectory = Path.GetDirectoryName(translationsPath);
            if (!Directory.Exists(translationDirectory))
            {
                Directory.CreateDirectory(translationDirectory);
                GreyHackRussianPlugin.Log.LogInfo($"Создана директория для переводов: {translationDirectory}");
            }

            if (!File.Exists(untranslatedPath))
            {
                GreyHackRussianPlugin.Log.LogInfo("Файл с непереведенными текстами не найден");
                return;
            }

            try
            {
                string content = File.ReadAllText(untranslatedPath, Encoding.UTF8);
                string[] blocks = content.Split(new[] { "\n\n---\n\n" }, StringSplitOptions.RemoveEmptyEntries);

                GreyHackRussianPlugin.Log.LogInfo($"Найдено {blocks.Length} блоков для перевода");

                // Создаем резервную копию файла переводов
                if (File.Exists(translationsPath))
                {
                    string backupPath = translationsPath + ".backup";
                    File.Copy(translationsPath, backupPath, true);
                    GreyHackRussianPlugin.Log.LogInfo($"Создана резервная копия переводов: {backupPath}");
                }

                // Обрабатываем блоки и добавляем переводы
                StringBuilder newTranslations = new StringBuilder();
                int processedBlocks = 0;

                foreach (var block in blocks)
                {
                    if (string.IsNullOrWhiteSpace(block)) continue;

                    // Строим структуру перевода блока
                    string translatedBlock = BuildTranslatedBlock(block);

                    // Добавляем оригинал=перевод в файл переводов
                    newTranslations.AppendLine($"{block.Trim()}={translatedBlock.Trim()}");
                    newTranslations.AppendLine();

                    processedBlocks++;
                }

                // Записываем новые переводы в файл
                File.AppendAllText(translationsPath, newTranslations.ToString(), Encoding.UTF8);

                // Очищаем обработанный файл debug_untranslated.txt
                File.WriteAllText(untranslatedPath, string.Empty);

                GreyHackRussianPlugin.Log.LogInfo($"Обработано и добавлено {processedBlocks} новых блоков переводов");
                GreyHackRussianPlugin.Log.LogInfo($"Файл переводов: {translationsPath}");
            }
            catch (Exception ex)
            {
                GreyHackRussianPlugin.Log.LogError($"Ошибка при обработке непереведенных текстов: {ex.Message}");
                GreyHackRussianPlugin.Log.LogDebug($"Stack trace: {ex.StackTrace}");
            }
        }

        /// <summary>
        /// Проверяет, является ли текст непереведенным на основе порога перевода
        /// </summary>
        private static bool IsUntranslated(string original, string translated)
        {
            if (original == translated) return true;

            // Делим на слова и считаем переведенные
            string[] originalWords = original.Split(new[] { ' ', '\n', '\t', '.', ',', ';', ':', '(', ')', '[', ']', '<', '>' },
                StringSplitOptions.RemoveEmptyEntries);

            string[] translatedWords = translated.Split(new[] { ' ', '\n', '\t', '.', ',', ';', ':', '(', ')', '[', ']', '<', '>' },
                StringSplitOptions.RemoveEmptyEntries);

            // Исключаем игнорируемые слова
            int originalCount = 0;
            foreach (var word in originalWords)
            {
                if (!ignoredWords.Contains(word.Trim().ToLower()))
                    originalCount++;
            }

            if (originalCount == 0) return false; // Все слова игнорируемые

            // Считаем процент переведенных слов (если совпадают оригинал и перевод, слово не переведено)
            float translationPercent = 1.0f - (float)Math.Min(originalCount, translatedWords.Length) / (float)originalCount;

            return translationPercent < translationThreshold;
        }

        /// <summary>
        /// Создает структурированный перевод блока текста с использованием алгоритмического перевода
        /// </summary>
        private static string BuildTranslatedBlock(string original)
        {
            // Сначала пытаемся перевести весь блок
            string translatedBlock = TranslateByParts(original);

            // Если это не помогло или перевод недостаточный, разбиваем на строки
            if (IsUntranslated(original, translatedBlock))
            {
                StringBuilder builder = new StringBuilder();
                string[] lines = original.Split(new[] { '\n' }, StringSplitOptions.None);

                foreach (var line in lines)
                {
                    // Переводим каждую строку
                    string translatedLine = TranslateByParts(line);
                    builder.AppendLine(translatedLine);
                }

                // Проверяем результат построчного перевода
                string lineByLineTranslation = builder.ToString().TrimEnd();

                // Используем лучший вариант перевода
                if (!IsUntranslated(original, lineByLineTranslation))
                    translatedBlock = lineByLineTranslation;
            }

            return translatedBlock;
        }

        /// <summary>
        /// Интеллектуальный перевод по частям с сохранением форматирования
        /// </summary>
        private static string TranslateByParts(string original)
        {
            string result = original;

            // Сохраняем HTML теги, заменяя их на временные метки
            Dictionary<string, string> htmlTags = new Dictionary<string, string>();
            int tagIndex = 0;

            // Особая обработка цветных тегов для сервисов ssh/ftp/http
            Regex serviceRegex = new Regex(@"<color=#0FABFFFF>([a-z]+)</color>");
            foreach (Match match in serviceRegex.Matches(original))
            {
                string service = match.Value;
                string placeholder = $"__SERVICE_{tagIndex}__";
                htmlTags[placeholder] = service;
                result = result.Replace(service, placeholder);
                tagIndex++;
            }

            // Регулярное выражение для поиска других HTML тегов
            var tagRegex = new Regex(@"<[^>]+>");
            foreach (Match match in tagRegex.Matches(result))
            {
                string tag = match.Value;
                if (!htmlTags.ContainsValue(tag)) // Пропускаем уже сохраненные сервисные теги
                {
                    string placeholder = $"__TAG_{tagIndex}__";
                    htmlTags[placeholder] = tag;
                    result = result.Replace(tag, placeholder);
                    tagIndex++;
                }
            }

            // Обработка специальных случаев (полные фразы с путями и т.д.)
            foreach (var specialCase in specialCases)
            {
                result = result.Replace(specialCase.Key, specialCase.Value);
            }

            // 1. Проверяем полные блоки текста через словарь переводов
            foreach (var kvp in Translation.Translator.TranslationDictionary)
            {
                if (result.Contains(kvp.Key) && kvp.Key.Length > 10)
                {
                    result = result.Replace(kvp.Key, kvp.Value);
                }
            }

            // 2. Заменяем общие фразы
            foreach (var phrase in commonPhrases)
            {
                if (result.Contains(phrase.Key))
                {
                    result = result.Replace(phrase.Key, phrase.Value);
                }
            }

            // 3. Применяем регулярные выражения для шаблонных замен
            foreach (var pattern in patterns)
            {
                result = Regex.Replace(result, pattern.Key, pattern.Value);
            }

            // Восстанавливаем HTML теги
            foreach (var tag in htmlTags)
            {
                result = result.Replace(tag.Key, tag.Value);
            }

            return result;
        }

        /// <summary>
        /// Harmony Postfix - вызывается после оригинального метода
        /// </summary>
        [HarmonyPostfix]
        static void Postfix(ref string __result)
        {
            try
            {
                // Проверка на пустую строку
                if (string.IsNullOrEmpty(__result))
                    return;

                string original = __result;

                // Проверяем, был ли этот текст уже переведен ранее
                if (translationCache.TryGetValue(original, out string cachedTranslation))
                {
                    __result = cachedTranslation;
                    GreyHackRussianPlugin.Log.LogInfo($"[Кэш] Использован кэшированный перевод описания ({translatedCount})");
                    return;
                }

                // Многоуровневый подход к переводу
                string translated = original;

                // 1. Сначала пытаемся найти точный перевод
                translated = Translation.Translator.TranslateTextIgnoreCase(original);

                // 2. Если точного перевода нет, пытаемся перевести частями с поддержкой форматирования HTML
                if (translated == original)
                {
                    translated = TranslateByParts(original);
                }

                // Если произошел перевод
                if (translated != original)
                {
                    // Проверяем качество перевода
                    if (IsUntranslated(original, translated))
                    {
                        // Текст переведен плохо - сохраняем в непереведенные
                        GreyHackRussianPlugin.Log.LogInfo($"[!] Перевод неполный, качество ниже порога ({translationThreshold * 100}%)");

                        try
                        {
                            // Ограничиваем запись в файлы
                            if (!hasDebuggedTranslation)
                            {
                                SaveUntranslatedText(original);

                                // Каждые 5 непереведенных текстов обрабатываем автоматически
                                if (untranslatedCount % 5 == 0)
                                {
                                    ProcessUntranslatedTexts();
                                    // Не сбрасываем флаг, чтобы не собирать слишком много
                                    // hasDebuggedTranslation = false;
                                }
                                else
                                {
                                    // После первой записи ставим флаг, чтобы не писать слишком много
                                    hasDebuggedTranslation = true;
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            GreyHackRussianPlugin.Log.LogError($"Ошибка при сохранении непереведенного текста: {ex.Message}");
                        }
                    }

                    // Всё равно используем частичный перевод
                    __result = translated;
                    translatedCount++;

                    // Добавляем в кэш для повторного использования
                    translationCache[original] = translated;

                    // Выводим информацию о переводе в лог (первые 100 символов)
                    int previewLength = Math.Min(100, original.Length);
                    string originalPreview = original.Substring(0, previewLength) + (original.Length > previewLength ? "..." : "");
                    string translatedPreview = translated.Substring(0, Math.Min(100, translated.Length)) + (translated.Length > previewLength ? "..." : "");

                    // Агрессивное логирование
                    GreyHackRussianPlugin.Log.LogInfo("=== ПЕРЕВОД ОПИСАНИЯ ЭКСПЛОЙТА ===");
                    GreyHackRussianPlugin.Log.LogInfo($"Перевод #{translatedCount}");
                    GreyHackRussianPlugin.Log.LogInfo($"ОРИГИНАЛ: {originalPreview}");
                    GreyHackRussianPlugin.Log.LogInfo($"ПЕРЕВОД: {translatedPreview}");
                    GreyHackRussianPlugin.Log.LogInfo("================================");
                }
                else
                {
                    // Вывод в лог информации о непереведенном тексте
                    GreyHackRussianPlugin.Log.LogInfo($"[!] Не найден перевод для описания ({original.Length} символов)");
                    GreyHackRussianPlugin.Log.LogInfo($"===== НЕПЕРЕВЕДЕННЫЙ ТЕКСТ =====");
                    GreyHackRussianPlugin.Log.LogInfo(original);
                    GreyHackRussianPlugin.Log.LogInfo("===============================");

                    try
                    {
                        // Ограничиваем запись в файлы для предотвращения слишком большого размера
                        if (!hasDebuggedTranslation)
                        {
                            // Сохраняем непереведенный текст
                            SaveUntranslatedText(original);

                            // Каждые 5 непереведенных текстов обрабатываем автоматически
                            if (untranslatedCount % 5 == 0)
                            {
                                ProcessUntranslatedTexts();
                                // Не сбрасываем флаг полностью, но позволяем собрать еще несколько текстов
                                hasDebuggedTranslation = false;
                            }
                            else
                            {
                                // После первой записи ставим флаг, чтобы не писать слишком много
                                hasDebuggedTranslation = true;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        GreyHackRussianPlugin.Log.LogError($"Ошибка при сохранении непереведенного текста: {ex.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                GreyHackRussianPlugin.Log.LogError($"Ошибка при переводе описания: {ex.Message}");
                GreyHackRussianPlugin.Log.LogDebug($"Stack trace: {ex.StackTrace}");
            }
        }

        /// <summary>
        /// Экспорт всех непереведенных текстов в файл переводов
        /// </summary>
        /// <returns>Количество обработанных блоков</returns>
        public static int ExportAllUntranslated()
        {
            GreyHackRussianPlugin.Log.LogInfo("Начинаем экспорт всех непереведенных текстов");

            // Сброс флага для записи всех непереведенных текстов
            hasDebuggedTranslation = false;

            // Обработка имеющихся непереведенных текстов
            ProcessUntranslatedTexts();

            // Возвращаем количество обработанных блоков
            return untranslatedCount;
        }
    }
}