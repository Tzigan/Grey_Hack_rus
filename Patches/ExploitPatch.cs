using HarmonyLib;
using System;
using System.IO;
using System.Reflection;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace GreyHackRussian.Patches
{
    /// <summary>
    /// Патч метода GetShopDescription с интеллектуальным сопоставлением текстов
    /// </summary>
    [HarmonyPatch(typeof(Exploit), "GetShopDescription")]
    public class ExploitPatch
    {
        // Словарь для кэширования переведенных описаний
        private static readonly Dictionary<string, string> translationCache = new Dictionary<string, string>();

        // Счетчик переведенных описаний
        private static int translatedCount = 0;

        // Список общих фраз для замены
        private static readonly Dictionary<string, string> commonPhrases = new Dictionary<string, string>
        {
            { "Get access to a shell.", "Получить доступ к оболочке." },
            { "Remote use.", "Удаленное использование." },
            { "For local use only.", "Только для локального использования." },
            { "Permissions obtained:", "Полученные разрешения:" },
            { "Target:", "Цель:" },
            { "Required:", "Требуется:" },
            { "guest", "гостевой" },
            { "Non root user", "Пользователь без root-прав" },
            { "Root user logged in the computer", "Root-пользователь, авторизованный на компьютере" },
            { "Guest user logged in the computer", "Гостевой пользователь, авторизованный на компьютере" },
            { "Any user logged in the computer", "Любой пользователь, авторизованный на компьютере" },
            { "Take advantage of a vulnerability in the", "Использует уязвимость в" },
            { "service to inject a new password to a registered user", "сервисе для внедрения нового пароля зарегистрированному пользователю" },
            { "Search all the Bank credentials files in the computer to decipher all passwords", "Ищет все файлы банковских учетных данных в компьютере для расшифровки всех паролей" },
            { "It is necessary to have the decipher program installed in the computer that launch the exploit", "Необходимо иметь программу расшифровки, установленную на компьютере, запускающем эксплойт" },
            { "Prints the contents of the file", "Выводит содержимое файла" },
            { "Grant access to the file", "Предоставляет доступ к файлу" },
            { "Grant access to the path", "Предоставляет доступ к пути" },
            { "and prints their contents", "и выводит их содержимое" },
            { "and decipher its contents", "и расшифровывает его содержимое" }
        };

        // Шаблоны для замены
        private static readonly Dictionary<string, string> patterns = new Dictionary<string, string>
        {
            { @"Dependencies on library ([a-z0-9_\.]+) >= ([0-9\.]+)", "Зависимость от библиотеки $1 >= $2" },
            { @"Minimum number of ([0-9]+) users registered in the computer", "Минимум $1 пользователей, зарегистрированных на компьютере" },
            { @"([\/a-zA-Z0-9_\.]+) exists in the file system", "$1 существует в файловой системе" }
        };

        static void Postfix(ref string __result)
        {
            try
            {
                // Проверка на пустую строку
                if (string.IsNullOrEmpty(__result))
                    return;

                string original = __result;

                // Проверяем, был ли этот текст уже переведен ранее
                if (translationCache.TryGetValue(original, out string cachedTranslation))
                {
                    __result = cachedTranslation;
                    GreyHackRussianPlugin.Log.LogInfo($"[Кэш] Использован кэшированный перевод описания ({translatedCount})");
                    return;
                }

                // Многоуровневый подход к переводу
                string translated = original;

                // 1. Сначала пытаемся найти точный перевод
                translated = Translator.TranslateTextIgnoreCase(original);

                // 2. Если точного перевода нет, пытаемся перевести частями с поддержкой форматирования HTML
                if (translated == original)
                {
                    translated = TranslateByParts(original);
                }

                // Если произошел перевод
                if (translated != original)
                {
                    __result = translated;
                    translatedCount++;

                    // Добавляем в кэш для повторного использования
                    translationCache[original] = translated;

                    // Выводим информацию о переводе в лог (первые 100 символов)
                    int previewLength = Math.Min(100, original.Length);
                    string originalPreview = original.Substring(0, previewLength) + (original.Length > previewLength ? "..." : "");
                    string translatedPreview = translated.Substring(0, Math.Min(100, translated.Length)) + (translated.Length > previewLength ? "..." : "");

                    // Агрессивное логирование
                    GreyHackRussianPlugin.Log.LogInfo("=== ПЕРЕВОД ОПИСАНИЯ ЭКСПЛОЙТА ===");
                    GreyHackRussianPlugin.Log.LogInfo($"Перевод #{translatedCount}");
                    GreyHackRussianPlugin.Log.LogInfo($"ОРИГИНАЛ: {originalPreview}");
                    GreyHackRussianPlugin.Log.LogInfo($"ПЕРЕВОД: {translatedPreview}");
                    GreyHackRussianPlugin.Log.LogInfo("================================");
                }
                else
                {
                    // Вывод в лог информации о непереведенном тексте
                    GreyHackRussianPlugin.Log.LogInfo($"[!] Не найден перевод для описания ({original.Length} символов)");
                    GreyHackRussianPlugin.Log.LogInfo($"===== НЕПЕРЕВЕДЕННЫЙ ТЕКСТ =====");
                    GreyHackRussianPlugin.Log.LogInfo(original);
                    GreyHackRussianPlugin.Log.LogInfo("===============================");

                    try
                    {
                        // Сохранение для отладки
                        string untranslatedPath = Path.Combine(GreyHackRussianPlugin.PluginPath, "debug_untranslated.txt");
                        File.AppendAllText(untranslatedPath, original + "\n\n---\n\n");

                        // Сохранение для файла переводов с замененными HTML тегами для удобства
                        string exportPath = Path.Combine(GreyHackRussianPlugin.PluginPath, "export_translations.txt");

                        // Формат для переводов: оригинал=перевод
                        File.AppendAllText(exportPath, original + "=" + original + "\n\n");

                        // Также создаем файл с разбиением на строки для удобства перевода
                        string splitPath = Path.Combine(GreyHackRussianPlugin.PluginPath, "split_translations.txt");

                        // Разделяем текст на строки по переносам и HTML тегам
                        string[] lines = original.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
                        foreach (var line in lines)
                        {
                            if (!string.IsNullOrWhiteSpace(line))
                            {
                                File.AppendAllText(splitPath, line.Trim() + "=" + line.Trim() + "\n");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        GreyHackRussianPlugin.Log.LogError($"Ошибка при сохранении непереведенного текста: {ex.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                GreyHackRussianPlugin.Log.LogError($"Ошибка при переводе описания: {ex.Message}");
                GreyHackRussianPlugin.Log.LogDebug($"Stack trace: {ex.StackTrace}");
            }
        }

        /// <summary>
        /// Интеллектуальный перевод по частям с сохранением форматирования
        /// </summary>
        private static string TranslateByParts(string original)
        {
            string result = original;

            // 1. Проверяем сначала полные блоки текста через словарь переводов
            foreach (var kvp in Translator.TranslationDictionary)
            {
                if (original.Contains(kvp.Key) && kvp.Key.Length > 10)
                {
                    result = result.Replace(kvp.Key, kvp.Value);
                }
            }

            // 2. Заменяем общие фразы
            foreach (var phrase in commonPhrases)
            {
                if (result.Contains(phrase.Key))
                {
                    result = result.Replace(phrase.Key, phrase.Value);
                }
            }

            // 3. Применяем регулярные выражения для шаблонных замен
            foreach (var pattern in patterns)
            {
                result = Regex.Replace(result, pattern.Key, pattern.Value);
            }

            // Проверяем, произошли ли изменения
            return (result != original) ? result : original;
        }
    }
}